% Copyright (C) Daphne Koller, Stanford University, 2012

function [MEU OptimalDecisionRule] = OptimizeMEU( I )

  % Inputs: An influence diagram I with a single decision node and a single utility node.
  %         I.RandomFactors = list of factors for each random variable.  These are CPDs, with
  %              the child variable = D.var(1)
  %         I.DecisionFactors = factor for the decision node.
  %         I.UtilityFactors = list of factors representing conditional utilities.
  % Return value: the maximum expected utility of I and an optimal decision rule 
  % (represented again as a factor) that yields that expected utility.
  
  % We assume I has a single decision node.
  % You may assume that there is a unique optimal decision.
  D = I.DecisionFactors(1);

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  % YOUR CODE HERE...
  % 
  % Some other information that might be useful for some implementations
  % (note that there are multiple ways to implement this):
  % 1.  It is probably easiest to think of two cases - D has parents and D 
  %     has no parents.
  % 2.  You may find the Matlab/Octave function setdiff useful.
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
  EUF = CalculateExpectedUtilityFactor(I);
  if length(D.card) == 1 % binary decision, no parents
    
    Utilities = [0; 0];
    
    D1 = D;
    D1.val = [1 0];
    temp = FactorProduct(EUF, D1);
    Utilities(1) = sum(temp.val);
    
    D2 = D;
    D2.val = [0 1];
    temp = FactorProduct(EUF, D2);
    Utilities(2) = sum(temp.val);
    
    if Utilities(1) > Utilities(2)
      MEU = Utilities(1);
      OptimalDecisionRule = D1;
    else
      MEU = Utilities(2);
      OptimalDecisionRule = D2;
    end
    
  else
    
    N = length(D.card);
    Utilities = zeros(2^N, 1);
    valueList = Convert2(N);
    for i=1:size(valueList, 1)
      D.val = valueList(i, :);
      prod = FactorProduct(EUF, D);
      Utilities(i) = sum(prod.val);
    end
    [MEU, index] = max(Utilities);
    D.val = valueList(index, :);
    OptimalDecisionRule = D;
  end    

end

function valueList = Convert2(N)
    vlaueList = zeros(N, 2*N);
    for j=1:N
        tmp = dec2bin(j, N);
        for k=1:N
            valueList(j, 2 * k - 1) = 0;
            valueList(j, 2 * k) = 1;
        end
    end
    valueList = [1 0 1 0];
end